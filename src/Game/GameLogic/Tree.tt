<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ Import Namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#	
	var TransformationType = this.GetType();
    var HostProp = TransformationType.GetProperty("Host");
    if (HostProp != null)
    {
		var Host = (Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost)HostProp.GetValue(this, null);
		var HostService = (IServiceProvider)Host;
		var DTE = (EnvDTE.DTE)HostService.GetService(typeof(EnvDTE.DTE));
		var ProjectItem = DTE.Solution.FindProjectItem(Host.TemplateFile);
		var Project = ProjectItem.ContainingProject;	
	
		foreach (ProjectItem Item in Project.ProjectItems)
		{
			ProcessProjectItem(Item);
		}

		WriteHeader();
		WriteTreeElementsCode();		
    }		
#>

<#+
				
	
	public void ProcessProjectItem(ProjectItem projectItem)
	{
		var FileCodeModel = projectItem.FileCodeModel;
		
		if (FileCodeModel != null)
		{
			foreach (CodeElement CodeElement in FileCodeModel.CodeElements)
			{
				WalkElements(CodeElement);
			}
		}
		
		if (projectItem.ProjectItems != null)
		{
			foreach (ProjectItem ChildItem in projectItem.ProjectItems)
			{
				ProcessProjectItem(ChildItem);
			}
		}
	}

	public void WriteHeader() 
	{
		WriteLine("//------------------------------------------------------------------------------");
		WriteLine("// <auto-generated>");
		WriteLine("//     This code was generated by a tool on " + DateTime.Now.ToString() + ".");		
		WriteLine("//");
		WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
		WriteLine("//     the code is regenerated.");
		WriteLine("// </auto-generated>");
		WriteLine("//------------------------------------------------------------------------------");
		WriteLine("");		
	}

	public void WriteTreeElementsCode() 
	{
		WriteLine("namespace SessionSeven.Entities");
		WriteLine("{");
		
		var Indent = string.Empty.PadLeft(4*(1), ' ');
						
		WriteLine(Indent + "/// <summary>");
		WriteLine(Indent + "/// Autogenerated game object graph for easy access.");
		WriteLine(Indent + "/// </summary>");

		WriteLine(Indent + "public static partial class Tree");
		WriteLine(Indent + "{"); 

		Indent = Indent.PadLeft(4*(2), ' ');
		
		WriteLine(Indent + "public static STACK.World World;");


		foreach (KeyValuePair<string, List<TreeElement>> Entry in TreeElements) 
		{
			WriteLine("");
			var Parts = Entry.Key.Split('.');
			int i = 0 ;			
			
			for (i = 1; i < Parts.Length; i++) 
			{				
				Indent = Indent.PadLeft(4 * (i + 1), ' ');
				WriteLine(Indent + "public static partial class " + Parts[i]);				
				WriteLine(Indent + "{");				
			}

			Indent = Indent.PadLeft(4 * (i + 1), ' ');
			var first = true;

			foreach (var Element in Entry.Value)
			{
				if (!first) 
				{
					WriteLine("");
				}

				WriteLine(Indent + "public static string "+ Element.Name + "ID = \"" + Element.Fullname + "\";");								

				if (Element.ElementType == TreeElementType.Entity) 
				{
					WriteLine(Indent + "public static global::" + Element.Fullname + " " + Element.Name);
					WriteLine(Indent + "{");
					WriteLine(Indent + "    get");
					WriteLine(Indent + "    {");
					WriteLine(Indent + "        return (global::" + Element.Fullname + ")World.GetGameObject(" + Element.Name + "ID);");
					WriteLine(Indent + "    }");
					WriteLine(Indent + "}");
				}
				else
				{
					WriteLine(Indent + "public static global::" + Element.Fullname + " " + Element.Name);
					WriteLine(Indent + "{");
					WriteLine(Indent + "    get");
					WriteLine(Indent + "    {");
					WriteLine(Indent + "        return (global::" + Element.Fullname + ")World.GetScene(" + Element.Name + "ID);");
					WriteLine(Indent + "    }");
					WriteLine(Indent + "}");
				}	
				first = false;			
			}				
			
			for (; i > 1; i--) 
			{		
				Indent = string.Empty.PadLeft(4 * (i), ' ');		
				WriteLine(Indent + "}");				
			}
		}	

		WriteLine("");
		WriteLine(Indent + "public static void Reset(STACK.World world)");
		WriteLine(Indent + "{");
		WriteLine(Indent + "    World = world;");
		//foreach (KeyValuePair<string, List<TreeElement>> Entry in TreeElements) 
		//{
		//	foreach (var Element in Entry.Value) 
		//	{
		//		WriteLine(Indent + "    " + Entry.Key.Replace("SessionSeven.", "") + "._" + Element.Name+" = null;");
		//	}
		//}
		WriteLine(Indent + "}");

		WriteLine("    }");
		WriteLine("}");
	}
			
	public void WalkElements(CodeElement codeElement)
	{						
		switch(codeElement.Kind)
		{
			
			case vsCMElement.vsCMElementNamespace:
			{																				
				foreach (CodeElement Element in ((CodeNamespace)codeElement).Members)
				{
					WalkElements(Element);
				}
				break;
			}
			
			case vsCMElement.vsCMElementClass:
			{
				var CodeClass = (CodeClass)codeElement;
				var Name = CodeClass.Name;

				if (!CodeClass.IsDerivedFrom["STACK.Scene"] &&
					!CodeClass.IsDerivedFrom["STACK.Entity"] ||
					CodeClass.IsAbstract)
				{
					break;
				}		
					
				var FullName = CodeClass.FullName;
				var NS = FullName.Replace("Locked.", "Tree.");

				if (ProcessedObjects.Contains(NS)) 
				{
					break;
				}

				ProcessedObjects.Add(NS);

				var Parts = NS.Split('.');

				var MyParts = NS.Split('.').ToList();
				MyParts.RemoveAt(MyParts.Count() - 1);
				var Relevant = string.Join(".", MyParts);

				if (!TreeElements.ContainsKey(Relevant)) 
				{
					TreeElements[Relevant] = new List<TreeElement>();
				}

				TreeElements[Relevant].Add(TreeElement.Create(FullName, Name, CodeClass.IsDerivedFrom["STACK.Entity"] ? TreeElementType.Entity : TreeElementType.Scene));

				break;
			}
		}		
	}
	
	
private List<string> ProcessedObjects = new List<string>();

enum TreeElementType { Entity, Scene };

class TreeElement 
{
	public string Fullname {get; set;}
	public string Name {get; set;}
	public TreeElementType ElementType {get; set;}

	public static TreeElement Create(string fullname, string name, TreeElementType type) 
	{
		return new TreeElement() 
		{
			Fullname = fullname,
			Name = name,
			ElementType = type
		};
	}
}

Dictionary<string, List<TreeElement>> TreeElements = new Dictionary<string, List<TreeElement>>();

#>